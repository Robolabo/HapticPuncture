/*
 ****************************************************************************
 *                     HAPTIC PUNCTURE SIMULATOR
 ****************************************************************************
 * Haptic Punture is an open-source, virtual reality based simulator 
 * for training in epidural procedures. The haptic device is composed by a 3D 
 * structure, moved by a DC motor. The position is recorded by an encoder. 
 * 
 * This code allows to measure the position information of the haptic device.
 * Then it sends it to the virtual environment (CHAI3D based) via port commu-
 * nication. Finally, the forces generated by the models simulation are tran-
 * slated to the motor.
 */

/*------------------------------------------------
 * author:          	      Juana González-Bueno
 * Robolabo, ETSIT, Technical University of Madrid
 * -----------------------------------------------
 */

#include <Encoder.h>
#include <DueTimer.h>
#include <stdlib.h>  

// Motor pins definition
int CHA   = 6;        // Input of A channel from the encoder
int CHB   = 7;        // Input of B channel from the encoder
int IN1   = A0;       // IN1 ouput to the motor's H bridge
int IN2   = A1;       // IN2 ouput to the motor's H bridge
int EN    = A4;       // EN output to enable the motor

// Variables declaration
int32_t   positionM;  // motors position given by the encoder
int       force;      // force sent to the H bridge as a PWM value
double    p;          // sampling period in [s]
int       maxPos;     // max encoder's position for this haptic device

// Encoder to read the motor's postition. 
Encoder myEnc(CHB, CHA);


void setup() {
  //Change the PWM frequency to 40KHz ----------------------------------------------------------------------------------------------------------------------------
  pmc_enable_periph_clk (PWM_INTERFACE_ID) ;  // turn on clocking to PWM unit

  //IN1A
  PWMC_ConfigureChannel (PWM, 0, 1, 0, PWM_CMR_CPOL) ;  // PWM, channel 0, divide CLKB = 84MHz by 2¹, alignment, polarity
  PWMC_SetPeriod (PWM, 0, 1050) ;             		// period = 1050 pwm clocks (20kHz) because: 1/((1/42000000)*1050)=40Khz
  PWMC_SetDutyCycle (PWM, 0, 100*1050/100) ;  		// duty set to 0% (CANAL 0 --> IN1A), with a 100% PWM because of the polarity
  PWMC_EnableChannel (PWM, 0) ;               		// enable
  
  //IN2A
  PWMC_ConfigureChannel (PWM, 1, 1, 0, PWM_CMR_CPOL) ;  // PWM, channel 1, divide CLKB = 84MHz by 2¹, alignment, polarity
  PWMC_SetPeriod (PWM, 1, 1050) ;           		// period = 1050 pwm clocks (20kHz) because 1/((1/42000000)*1050)=40Khz
  PWMC_SetDutyCycle (PWM, 1, 0*1050/100) ;  		// duty set to 0% (CANAL 1 --> IN2A)
  PWMC_EnableChannel (PWM, 1);             		// enable
  
  //IN1B
  PWMC_ConfigureChannel (PWM, 3, 1, 0, PWM_CMR_CPOL) ; 	// PWM, channel 3, divide CLKB = 84MHz by 2¹, alignment, polarity
  PWMC_SetPeriod (PWM, 3, 1050) ;           		// period = 1050 pwm clocks (20kHz) because 1/((1/42000000)*1050)=40Khz
  PWMC_SetDutyCycle (PWM, 3, 0*1050/100) ;  		// duty set to 0% (CANAL 3 --> IN1B)
  PWMC_EnableChannel (PWM, 3) ;             		// enable

  //IN2B
  PWMC_ConfigureChannel (PWM, 6, 1, 0, PWM_CMR_CPOL) ;  // PWM, channel 6, divide CLKB = 84MHz by 2¹, alignment, polarity
  PWMC_SetPeriod (PWM, 6, 1050) ;           		// period = 1050 pwm clocks (20kHz) because 1/((1/42000000)*1050)=40Khz
  PWMC_SetDutyCycle (PWM, 6, 0*1050/100) ;  		// duty set to 0% (CANAL 6 --> IN2B)
  PWMC_EnableChannel (PWM, 6) ;             		// enable

  // Configure pin PC3 (pin35), PC9 (pin 41) y PC18 (pin45) to be driven by peripheral B (PWM channel 0 L)
  // enable pin PC3 (pin35), PC9 (pin 41) y PC18 (pin45)
  PIOC->PIO_PDR = 0x40208 ;    // disable PIO control. 0x40200 Para los 2 pines
  PIOC->PIO_IDR = 0x40208 ;    // disable PIO interrupts
  PIOC->PIO_ABSR |= 0x40208 ;  // switch to B peripheral

  // Configure pin PA19 (pin42), to be driven by peripheral B (PWM channel 0 L) (with retrofeed)
  // enable pin PA19 (pin42)
  PIOA->PIO_PDR = 0x80000;    // disable PIO control
  PIOA->PIO_IDR = 0x80000;    // disable PIO interrupts
  PIOA->PIO_ABSR |= 0x80000;  // switch to B peripheral
  //-----------------------------------------------------------------------------------------------------------------------------------------------------------------
  
  // BaudRate = 115200 bps
  Serial.begin(115200);
  
  // Initialize output pin to the H bridge and enable it (now at 0V)
  pinMode(EN,OUTPUT);
  digitalWrite(EN, HIGH);

  // Change the default analogRead() resolution from 10 bits to 12 bits
  analogReadResolution(12);
  
  // Variables' initialization
  positionM     = 0;      // initial motor's position to 0
  p             = 0.0001; // sampling rate as 1ms
  maxPos        = 9000;   // measured with the current haptic device

  // Start timer to send and receive data
  Timer3.attachInterrupt(mainFunction);
  Timer3.start(p*1000000); // from [s] to [us]
  
}


/*
 * Function to set the motor's voltage by sending a PWM to the H bridge
 */
void setForce(){
  // When the force is 0: stop the motor
  if (force = 0.0){
    digitalWrite (EN, HIGH);
    PWMC_SetDutyCycle (PWM, 6, 0*1050/100) ;      // duty set to 0% (CHANNEL 3 --> IN1) (same as digitalWrite(IN1, LOW);)
    PWMC_SetDutyCycle (PWM, 3, 0*1050/100) ;      // duty set to 0% (CHANNEL 6 --> IN2) (same as digitalWrite(IN2, LOW);)
  }

  // When the force is positive, enable the H bridge and define de motor's direction as FORWARD
  else if (force > 0.0) {
    if (force > 100.0) {
      force = 100.0;
    }
    digitalWrite (EN, HIGH);
    PWMC_SetDutyCycle (PWM, 6, 0*1050/100) ;      // duty set to 0% (CHANNEL 6 --> IN2) (same as digitalWrite(IN2, LOW);)
    PWMC_SetDutyCycle (PWM, 3, force*1050/100) ;  // duty set to pwm% (CHANNEL 3 --> IN1)
  }

  // When the force is negative, enable the H bridge and define de motor's direction as BACKWARDS
  else if (force < 0.0) {
    if (force < -100.0) {
      force = -100.0;
    }
    digitalWrite (EN, HIGH);
    PWMC_SetDutyCycle (PWM, 3, 0*1050/100) ;      // duty set to 0% (CHANNEL 3 --> IN1)
    PWMC_SetDutyCycle (PWM, 6, -force*1050/100) ; // duty set to pwm% (CHANNEL 6 --> IN2)
  }
}

/*
 * Function send the position and receive the force.
 * Calls the setForce() function
 */
void mainFunction() {
  // Read the motor's position from the encoder
  // converted to a value from 0 to 255
  positionM = abs(myEnc.read()*255/maxPos);

  // Limitation of the variable
  if (positionM > 255) {
    positionM = 255;
  }

  // Send the position value through the port (0 to 255)
  // Receive the force value through the port (PWM)
  if (Serial.available() > 0) {
    Serial.write(positionM);
    force = Serial.read();
    setForce();
  }
}


/*
 * Eternal loop to make the program work
 */
void loop() {
  while(1){
  }
}
